(function() {
	const flatMap = (e, t) => t.reduce((t, a) => t.concat(e(a)), []),
		isEmpty = e => 0 !== e && (!e || "string" == typeof e && !e.trim()),
		unionType = (() => {
			let e = 0;
			return t => t.reduce((t, a) => ({
				...t,
				[a]: e++
			}), {})
		})(),
		State = unionType(["Text", "Tag", "ClosingTag", "Attr", "AttrKey", "AttrValue", "AttrValueSingleQuote", "AttrValueDoubleQuote"]),
		Token = unionType(["Text", "OpenTag", "AttributeName", "AttributeValue", "CloseTag", "SelfCloseTag", "ClosingTag", "VTree"]),
		Tree = unionType(["Node", "VTree", "Text"]);

	function tokenizer(e, t = State.Text, a = "") {
		let r = [],
			u = t,
			n = a;
		for (let t = 0; t < e.length; t++) {
			const a = e[t];
			switch (u) {
				case State.Text:
					"<" === a ? (isEmpty(n) || r.push({
						type: Token.Text,
						value: n
					}), n = "", u = State.Tag) : n += a;
					continue;
				case State.Tag:
					/\s/.test(a) ? (r.push({
						type: Token.OpenTag,
						value: n
					}), n = "", u = State.Attr) : ">" === a ? (r.push({
						type: Token.OpenTag,
						value: n
					}), r.push({
						type: Token.CloseTag
					}), n = "", u = State.Text) : "/" === a && "" === n ? u = State.ClosingTag : n += a;
					continue;
				case State.ClosingTag:
					">" === a ? (r.push({
						type: Token.ClosingTag,
						value: n
					}), n = "", u = State.Text) : n += a;
					continue;
				case State.Attr:
					">" === a ? ("/" === n ? r.push({
						type: Token.SelfCloseTag
					}) : r.push({
						type: Token.CloseTag
					}), n = "", u = State.Text) : /\s/.test(a) || ("/" === a ? n += a : (n += a, u = State.AttrKey));
					continue;
				case State.AttrKey:
					"=" === a ? ("" !== n && r.push({
						type: Token.AttributeName,
						value: n
					}), n = "", u = State.AttrValue) : /\s/.test(a) ? ("" !== n && r.push({
						type: Token.AttributeName,
						value: n
					}), n = "", u = State.Attr) : n += a;
					continue;
				case State.AttrValue:
					/\s/.test(a) ? (r.push({
						type: Token.AttributeValue,
						value: n
					}), n = "", u = State.Attr) : ">" === a ? (r.push({
						type: Token.AttributeValue,
						value: n
					}), r.push({
						type: Token.CloseTag
					}), n = "", u = State.Text) : "" === n && "'" === a ? u = State.AttrValueSingleQuote : "" === n && '"' === a ? u = State.AttrValueDoubleQuote : n += a;
					continue;
				case State.AttrValueSingleQuote:
					"'" === a ? (r.push({
						type: Token.AttributeValue,
						value: n
					}), n = "", u = State.Attr) : n += a;
					continue;
				case State.AttrValueDoubleQuote:
					'"' === a ? (r.push({
						type: Token.AttributeValue,
						value: n
					}), n = "", u = State.Attr) : n += a;
					continue
			}
		}
		return [r, u, n]
	}
	const parseObjectAttrs = e => [flatMap(([e, t]) => e.trim() ? [{
			type: Token.AttributeName,
			value: e
		}, {
			type: Token.AttributeValue,
			value: t
		}] : [], Object.entries(e)), State.Attr],
		parseStringAttrs = e => e.split(/\s+/).filter(e => e.trim()).reduce(([e], t) => {
			const [a, r] = t.split("=");
			return r ? [e.concat([{
				type: Token.AttributeName,
				value: a
			}, {
				type: Token.AttributeValue,
				value: r
			}]), State.Attr] : [e.concat([{
				type: Token.AttributeName,
				value: a
			}]), State.AttrKey]
		}, [
			[], State.Attr
		]);

	function variableTokenizer(e, t = Token.Text, a = "") {
		if (void 0 === e) return [
			[], t, a
		];
		let r = [],
			u = t,
			n = a;
		switch (u) {
			case State.Text:
				"object" == typeof e ? (isEmpty(n) || r.push({
					type: Token.Text,
					value: n
				}), r.push({
					type: Token.VTree,
					value: e
				}), n = "") : (isEmpty(n) || r.push({
					type: Token.Text,
					value: n
				}), isEmpty(e) || r.push({
					type: Token.Text,
					value: e.toString()
				}), n = "");
				break;
			case State.Tag:
			case State.ClosingTag:
				"" !== n ? n += e : n = e;
				break;
			case State.Attr:
				if ("object" == typeof e)[r, u] = parseObjectAttrs(e);
				else {
					if ("string" != typeof e) throw new Error(`Variable ${e} of type '${typeof e}' is not supported in the State.Attr context`);
					[r, u] = parseStringAttrs(e)
				}
				break;
			case State.AttrKey:
				throw new Error(`Variable ${e} of type '${typeof e}' is not supported in the State.AttrKey context`);
			case State.AttrValue:
			case State.AttrValueSingleQuote:
			case State.AttrValueDoubleQuote:
				"" !== n ? n += e : n = e
		}
		return [r, u, n]
	}
	const tokenizerTag = (e, ...t) => {
			let a = [],
				r = State.Text,
				u = "";
			for (let n = 0; n < e.length; n++) {
				const o = e[n],
					l = t[n],
					[s, T, p] = tokenizer(o, r, u),
					[i, c, y] = variableTokenizer(l, T, p);
				a = a.concat(s).concat(i), r = c, u = y
			}
			return a
		},
		NAME_INDEX = 0,
		ATTR_INDEX = 1,
		CHILDREN_INDEX = 2,
		applyH = (e, t) => t.map(t => {
			switch (t.type) {
				case Tree.Node:
					return e(t.value[0], t.value[ATTR_INDEX], applyH(e, t.value[CHILDREN_INDEX]));
				case Tree.VTree:
				case Tree.Text:
					return t.value
			}
		});

	function buildTree(e, t = 0) {
		let a = [],
			r = t;
		for (; r < e.length;) {
			const t = e[r],
				u = a[a.length - 1],
				n = u && u.type === Tree.Node ? u.value : null;
			switch (t.type) {
				case Token.OpenTag:
					a.push({
						type: Tree.Node,
						value: [t.value, {},
							[]
						]
					}), r++;
					break;
				case Token.Text:
					a.push({
						type: Tree.Text,
						value: t.value
					}), r++;
					break;
				case Token.VTree:
					a.push(...Array.isArray(t.value) ? t.value.map(e => ({
						type: Tree.VTree,
						value: e
					})) : [{
						type: Tree.VTree,
						value: t.value
					}]), r++;
					break;
				case Token.AttributeName:
					n ? e[r + 1] && e[r + 1].type === Token.AttributeValue ? (n[ATTR_INDEX][t.value] = e[r + 1].value, r += 2) : (n[ATTR_INDEX][t.value] = !0, r++) : r++;
					break;
				case Token.AttributeValue:
					break;
				case Token.CloseTag:
					if (n) {
						let [t, a] = buildTree(e, r + 1);
						n[CHILDREN_INDEX] = t, r = a
					} else r++;
					break;
				case Token.SelfCloseTag:
					r++;
					break;
				case Token.ClosingTag:
					return [a, r + 1]
			}
		}
		return [a, r]
	}
	const unwrapIfOnlyValue = e => 1 === e.length ? e[0] : e;

	function createParser(e) {
		return (...t) => {
			const [a] = buildTree(tokenizerTag(...t));
			return unwrapIfOnlyValue(applyH(e, a))
		}
	}


	window.hyperx = createParser;

})();