<!DOCTYPE html>
<!-- Doctype HTML5 -->
<html lang='en'>
	<head>
		<meta charset='utf-8'>
		<meta name='viewport' content='width=device-width, initial-scale=1'>

		<title>XO test</title>
	</head>
	<body>
		<div id='root'><div></div></div>

	</body>


<!-- This example should be a component that render N counters. Each counter keeps it's own state and increments -->


<script type="text/javascript">




</script>




<script type="text/javascript">


// This will automatically generated from parsing html template strings.
// The keys will be Symbols, instead of nice names
const Components = {
	Counter : {
		/*h`<div class='Counter'>
			<button onclick=${()=>inc()}>inc</button>
			<span>${count}</span>
		</div>`
		*/
		template : `<div class='Counter'>
			<button>inc</button>
			<span>[counter]</span>
		</div>`,
		update : [
			(val, root)=>root.children[0].onclick=val,
			(val, root)=>root.children[1].innerHTML=val,
		]
	},

	List : {
		/*h`<div class='List'>
			<h1>${title}</h1>
			<div>${children}</div>
		</div>`
		*/
		template : `<div class='List'><h1>[title]</h1><div>[placeholder]</div></div>`,
		update : [
			(val, root)=>root.children[0].innerHTML=val,
			(val, root)=>root.children[1].innerHTML=val,
		]
	},

	Link : {
		template : `<a></a>`,
		update : [
			(val, root)=>root.setAttribute('href', val),
			(val, root)=>root.innerHTML=val
		]
	}
};




let Data = {
	/*
		id:
		el:
		deps : [
			//either data OR components



		]



	*/


}


/*
{
	- props
	- state
	- effects
	- el
	- func ref
	- children : []
}



*/

let curr = []
const dataStruct = {children : []}


const comp = (id, func)=>{

	return (...args)=>{


		console.log('starting comp', id)
		//follow the curr to the current data structure

		console.log(curr)

		let ds = curr.reduce((acc, idx)=>acc.children[idx], dataStruct);
		console.log(ds)

		ds.children.push({
			id,
			children : []
		});

		curr.push(0)


		let res = func(...args);

		console.log(res);


		console.log('ending comp', id);

		curr.pop();


		return res;

	}


}



const Counter = comp('counter', (idx)=>{

	//const [count, setCount] = this.useState(0);
	const count = 4;

	const inc = ()=>{
		//setCount(count + 1)
		alert('yo');
	}


	return {
		isComp : true,
		id : 'Counter',
		comp : Components.Counter,
		data:[
			inc,
			count
		]
	}
})



const times = (n,fn)=>Array.from(new Array(n*1),(v,i)=>fn(i));

const List = comp('list', (title, numButtons=2)=>{

	return {
		isComp : true,
		id : 'List',
		comp : Components.List,
		data: [
			title,
			times(numButtons, (i)=>{
				return Counter(i);
			})
		]
	}



})





//////////////

let Root = document.getElementById('root');


//Root = Root.outerHTML = `<a href='test'><div>yo</div></a>`;



const string2DOM = (htmlString)=>{
	let temp = document.createElement('template');
	temp.innerHTML = htmlString;
	return temp.content.firstChild;
}

const replaceElement = (target, html)=>{
	const el = string2DOM(html);
	target.replaceWith(el)
	return el;
}



const render = (root, compResult, cache = dataStruct)=>{

	const Comp = compResult.comp

	if(!cache.el){
		console.log('rendering')
		cache.el = replaceElement(root, Comp.template)
	}


	compResult.data.map((datum, idx)=>{
		console.log(idx, datum);
		console.log(compResult)


		//TODO: something different if it's a component

		compResult.comp.update[idx](datum, cache.el);
	})


}










const temp = List('Test', 4);



render(Root, temp);







//////////////////







const compareCache = (idx, newVal, _cache)=>{
	let val = newVal;
	if(typeof newVal == 'function' || Array.isArray(newVal)) val = newVal.toString();

	if(_cache[idx] !== val){
		_cache[idx] = val
		return true;
	}
	return false;
}

// const render = (target, comp)=>{
// 	if(cache.length == 0){
// 		target.innerHTML = comp.template;
// 	}

// 	const root = target.children[0];
// 	console.log(root.children)

// 	//update
// 	comp.data.map((val, idx)=>{>
// 		if(compareCache(idx, val, cache)){
// 			console.log('updating', idx, val)
// 			comp.update[idx](val, root);
// 			//cache[idx] = val;
// 		}
// 	})
// }

// const replaceElement = (target, template)=>{
// 	target.parentNode.insertBefore(template.content.cloneNode(true), target);
// 	let temp = target.previousElementSibling;
// 	target.parentNode.removeChild(target);
// 	return temp;
// }






let cache = {};

// const render = (target, comp, id='0')=>{
// 	//target.innerHTML = comp.template;
// 	//target.replaceWith(comp.template)
// 	// let temp = comp.template.node.content.cloneNode(true)
// 	// target.parentNode.replaceChild(temp, target);
// 	// console.log(temp.parentNode)

// 	//this should be cached
// 	if(!cache[id]){
// 		console.log('creating element', id)
// 		cache[id] = {node : replaceElement(target, comp.template.node), data : []};
// 	}

// 	// //update
// 	comp.data.map((val, idx)=>{
// 		if(val.isComp){
// 			render(comp.template.update[idx](val, cache[id].node), val, id + idx);
// 		}else{
// 			if(compareCache(idx, val, cache[id].data)){
// 				console.log(id, 'updating', idx);
// 				comp.template.update[idx](val, cache[id].node);
// 			}
// 		}

// 	})
// }


//////////////////////////////////////////////////////////////


// //const Root = document.getElementById('root');

// let compTree = Counter({
// 	bgColor : 'red',
// 	onClick : ()=>alert('yo'),
// 	text : 'Lets go',
// 	number : 4,
// 	link : 'https://www.youtube.com/watch?v=h9tLcD1r-6w',
// 	boop : 'yoyoyoy'
// })





// render(Root.children[0], compTree)

// console.log(cache)
// console.log('-------')

// setTimeout(()=>{

// 	compTree = Counter({
// 		bgColor : 'green',
// 		onClick : ()=>alert('yo'),
// 		text : 'Lets go',
// 		number : 4,
// 		link : 'https://www.youtube.com/watch?v=h9tLcD1r-6w',
// 		boop : 'UPDATE'
// 	})

// 	render(Root.children[0], compTree)

// 	console.log(cache)

// }, 500)






</script>
<script>

	const text = `<div>

		test
	</div>`


	parser = new DOMParser();
	xmlDoc = parser.parseFromString(text,"text/html");

	console.log(xmlDoc)


</script>
</html>